{"version":3,"names":["useTiming","toOrParams","config","callback","prevCfgRef","useRef","resolvedParameters","useMemo","nextParams","getResolvedParams","equals","current","value","useValue","from","prevAnimationRef","prevParamsRef","animation","createTiming","useEffect","undefined","a","b","JSON","stringify"],"sources":["useTiming.ts"],"sourcesContent":["import { useEffect, useMemo, useRef } from \"react\";\n\nimport type { SkiaValue, SkiaAnimation } from \"../../values/types\";\nimport type {\n  AnimationParams,\n  TimingConfig,\n  AnimationCallback,\n} from \"../types\";\nimport { useValue } from \"../../values/hooks/useValue\";\n\nimport { getResolvedParams } from \"./functions\";\nimport { createTiming } from \"./createTiming\";\n\n/**\n * Creats an animation value that will run whenever\n * the animation parameters change. The animation start immediately.\n * @param toOrParams\n * @param config\n * @returns A value that is animated\n */\nexport const useTiming = (\n  toOrParams: number | AnimationParams,\n  config?: TimingConfig,\n  callback?: AnimationCallback\n): SkiaValue<number> => {\n  // Resolve parameters - keep a cached version to avoid\n  // unnecesary re-renders.\n  const prevCfgRef = useRef<ReturnType<typeof getResolvedParams>>();\n  const resolvedParameters = useMemo(() => {\n    const nextParams = getResolvedParams(toOrParams, config);\n    if (!equals(prevCfgRef.current, nextParams)) {\n      prevCfgRef.current = nextParams;\n    }\n    return prevCfgRef.current!;\n  }, [config, toOrParams]);\n\n  // Create value\n  const value = useValue(resolvedParameters.from ?? 0);\n\n  // Create timing animation - keep a cached version to avoid\n  // uneccessary recreation of animations\n  const prevAnimationRef = useRef<SkiaAnimation>();\n  const prevParamsRef = useRef<typeof resolvedParameters>();\n  const animation = useMemo(() => {\n    if (!equals(prevParamsRef.current, resolvedParameters)) {\n      prevParamsRef.current = resolvedParameters;\n      prevAnimationRef.current = createTiming(\n        resolvedParameters,\n        value,\n        callback\n      );\n    }\n    return prevAnimationRef.current!;\n  }, [callback, resolvedParameters, value]);\n\n  // Run animation on the value - and stop it on unmount\n  useEffect(() => {\n    value.animation = animation;\n    return () => (value.animation = undefined);\n  }, [animation, value]);\n\n  // Return the value that is animated\n  return value;\n};\n\nconst equals = <T1, T2>(a: T1, b: T2) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n"],"mappings":";;;;;;;AAAA;;AAQA;;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,SAAS,GAAG,CACvBC,UADuB,EAEvBC,MAFuB,EAGvBC,QAHuB,KAID;EACtB;EACA;EACA,MAAMC,UAAU,GAAG,IAAAC,aAAA,GAAnB;EACA,MAAMC,kBAAkB,GAAG,IAAAC,cAAA,EAAQ,MAAM;IACvC,MAAMC,UAAU,GAAG,IAAAC,4BAAA,EAAkBR,UAAlB,EAA8BC,MAA9B,CAAnB;;IACA,IAAI,CAACQ,MAAM,CAACN,UAAU,CAACO,OAAZ,EAAqBH,UAArB,CAAX,EAA6C;MAC3CJ,UAAU,CAACO,OAAX,GAAqBH,UAArB;IACD;;IACD,OAAOJ,UAAU,CAACO,OAAlB;EACD,CAN0B,EAMxB,CAACT,MAAD,EAASD,UAAT,CANwB,CAA3B,CAJsB,CAYtB;;EACA,MAAMW,KAAK,GAAG,IAAAC,kBAAA,EAASP,kBAAkB,CAACQ,IAAnB,IAA2B,CAApC,CAAd,CAbsB,CAetB;EACA;;EACA,MAAMC,gBAAgB,GAAG,IAAAV,aAAA,GAAzB;EACA,MAAMW,aAAa,GAAG,IAAAX,aAAA,GAAtB;EACA,MAAMY,SAAS,GAAG,IAAAV,cAAA,EAAQ,MAAM;IAC9B,IAAI,CAACG,MAAM,CAACM,aAAa,CAACL,OAAf,EAAwBL,kBAAxB,CAAX,EAAwD;MACtDU,aAAa,CAACL,OAAd,GAAwBL,kBAAxB;MACAS,gBAAgB,CAACJ,OAAjB,GAA2B,IAAAO,0BAAA,EACzBZ,kBADyB,EAEzBM,KAFyB,EAGzBT,QAHyB,CAA3B;IAKD;;IACD,OAAOY,gBAAgB,CAACJ,OAAxB;EACD,CAViB,EAUf,CAACR,QAAD,EAAWG,kBAAX,EAA+BM,KAA/B,CAVe,CAAlB,CAnBsB,CA+BtB;;EACA,IAAAO,gBAAA,EAAU,MAAM;IACdP,KAAK,CAACK,SAAN,GAAkBA,SAAlB;IACA,OAAO,MAAOL,KAAK,CAACK,SAAN,GAAkBG,SAAhC;EACD,CAHD,EAGG,CAACH,SAAD,EAAYL,KAAZ,CAHH,EAhCsB,CAqCtB;;EACA,OAAOA,KAAP;AACD,CA3CM;;;;AA6CP,MAAMF,MAAM,GAAG,CAASW,CAAT,EAAgBC,CAAhB,KAA0B;EACvC,OAAOC,IAAI,CAACC,SAAL,CAAeH,CAAf,MAAsBE,IAAI,CAACC,SAAL,CAAeF,CAAf,CAA7B;AACD,CAFD"}