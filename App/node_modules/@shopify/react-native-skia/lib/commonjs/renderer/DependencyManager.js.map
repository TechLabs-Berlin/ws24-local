{"version":3,"names":["DependencyManager","constructor","registerValues","Map","unsubscribeNode","node","subscriptions","Array","from","values","filter","p","nodes","has","forEach","si","delete","size","unsubscribe","Error","element","entries","find","_","sub","subscribeNode","props","propSubscriptions","initializePropertySubscriptions","length","ps","subscriptionState","get","value","addListener","v","mutators","m","set","map","mutator","update","unregisterDependantValues","keys","remove","clear","nodePropSubscriptions","mapKeys","key","propvalue","isValue","push","setProp","current","isSelector","selector"],"sources":["DependencyManager.tsx"],"sourcesContent":["import type { Node } from \"../dom/types\";\nimport type { SkiaValue } from \"../values\";\n\nimport type { AnimatedProps } from \"./processors\";\nimport { isSelector, isValue } from \"./processors\";\nimport { mapKeys } from \"./typeddash\";\n\ntype Unsubscribe = () => void;\ntype Mutator = (value: unknown) => void;\n\ntype SubscriptionState = {\n  nodes: Map<Node<unknown>, Mutator[]>;\n  unsubscribe: null | Unsubscribe;\n};\n\nexport class DependencyManager {\n  registerValues: (values: Array<SkiaValue<unknown>>) => () => void;\n  subscriptions: Map<SkiaValue<unknown>, SubscriptionState> = new Map();\n  unregisterDependantValues: null | Unsubscribe = null;\n\n  constructor(\n    registerValues: (values: Array<SkiaValue<unknown>>) => () => void\n  ) {\n    this.registerValues = registerValues;\n  }\n\n  /**\n   * Call to unsubscribe all value listeners from the given node based\n   * on the current list of subscriptions for the node. This function\n   * is typically called when the node is unmounted or when one or more\n   * properties have changed.\n   * @param node Node to unsubscribe value listeners from\n   */\n  unsubscribeNode(node: Node<unknown>) {\n    const subscriptions = Array.from(this.subscriptions.values()).filter((p) =>\n      p.nodes.has(node)\n    );\n\n    if (subscriptions) {\n      subscriptions.forEach((si) => {\n        // Delete node from subscription\n        si.nodes.delete(node);\n\n        // Remove subscription if there are no listeneres left on the value\n        if (si.nodes.size === 0) {\n          // There are no more nodes subscribing to this value, we can call\n          // unsubscribe on it.\n          if (!si.unsubscribe) {\n            throw new Error(\"Failed to unsubscribe to value subscription\");\n          }\n          si.unsubscribe && si.unsubscribe();\n\n          // Remove from subscription states as well\n          const element = Array.from(this.subscriptions.entries()).find(\n            ([_, sub]) => sub === si\n          );\n          if (!element) {\n            throw new Error(\"Failed to find value subscription\");\n          }\n          if (!this.subscriptions.delete(element[0])) {\n            throw new Error(\"Failed to delete value subscription\");\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Adds listeners to the provided values so that the node is notified\n   * when a value changes. This is done in an optimized way so that this\n   * class only needs to listen to the value once and then forwards the\n   * change to the node and its listener. This method is typically called\n   * when the node is mounted and when one or more props on the node changes.\n   * @param node Node to subscribe to value changes for\n   * @param props Node's properties\n   */\n  subscribeNode<P>(node: Node<unknown>, props: AnimatedProps<P>) {\n    // Get mutators from node's properties\n    const propSubscriptions = initializePropertySubscriptions(node, props);\n    if (propSubscriptions.length === 0) {\n      return;\n    }\n\n    // Install all mutators for the node\n    propSubscriptions.forEach((ps) => {\n      // Do we already have a state for this SkiaValue\n      let subscriptionState = this.subscriptions.get(ps.value);\n      if (!subscriptionState) {\n        // Let's create a new subscription state for the skia value\n        subscriptionState = {\n          nodes: new Map(),\n          unsubscribe: null,\n        };\n        // Add single subscription to the new value\n        subscriptionState.unsubscribe = ps.value.addListener((v) => {\n          subscriptionState!.nodes.forEach((mutators) =>\n            mutators.forEach((m) => m(v))\n          );\n        });\n        this.subscriptions.set(ps.value, subscriptionState);\n      }\n      // subscription mutators\n      subscriptionState.nodes.set(\n        node,\n        propSubscriptions\n          .filter((m) => m.value === ps.value)\n          .map((m) => m.mutator)\n      );\n    });\n  }\n\n  /**\n   * Called when the hosting container is mounted or updated. This ensures that we have\n   * a ref to the underlying SkiaView so that we can registers redraw listeners\n   * on values used in the current View automatically.\n   */\n  update() {\n    // Remove any previous registrations\n    if (this.unregisterDependantValues) {\n      this.unregisterDependantValues();\n    }\n\n    // Register redraw requests on the SkiaView for each unique value\n    this.unregisterDependantValues = this.registerValues(\n      Array.from(this.subscriptions.keys())\n    );\n  }\n\n  /**\n   * Called when the hosting container is unmounted or recreated. This ensures that we remove\n   * all subscriptions to Skia values so that we don't have any listeners left after\n   * the component is removed.\n   */\n  remove() {\n    // 1) Unregister redraw requests\n    if (this.unregisterDependantValues) {\n      this.unregisterDependantValues();\n      this.unregisterDependantValues = null;\n    }\n\n    // 2) Unregister nodes\n    Array.from(this.subscriptions.values()).forEach((si) => {\n      Array.from(si.nodes.keys()).forEach((node) => this.unsubscribeNode(node));\n    });\n\n    // 3) Clear the rest of the subscriptions\n    this.subscriptions.clear();\n  }\n}\n\nconst initializePropertySubscriptions = <P,>(\n  node: Node<P>,\n  props: AnimatedProps<P>\n) => {\n  const nodePropSubscriptions: Array<{\n    value: SkiaValue<unknown>;\n    mutator: Mutator;\n  }> = [];\n\n  mapKeys(props).forEach((key) => {\n    if (key === \"children\") {\n      return;\n    }\n    const propvalue = props[key];\n\n    if (isValue(propvalue)) {\n      // Subscribe to changes\n      nodePropSubscriptions.push({\n        value: propvalue,\n        mutator: (v) => {\n          node.setProp(key, v as P[typeof key]);\n        },\n      });\n      // Set initial value\n      node.setProp(key, (propvalue as SkiaValue<P[typeof key]>).current);\n    } else if (isSelector(propvalue)) {\n      // Subscribe to changes\n      nodePropSubscriptions.push({\n        value: propvalue.value,\n        mutator: (v) => {\n          node.setProp(key, propvalue.selector(v) as P[typeof key]);\n        },\n      });\n      // Set initial value\n      node.setProp(\n        key,\n        propvalue.selector(propvalue.value.current) as P[typeof key]\n      );\n    } else {\n      // Set initial value\n      node.setProp(key, propvalue as P[typeof key]);\n    }\n  });\n\n  return nodePropSubscriptions;\n};\n"],"mappings":"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"}