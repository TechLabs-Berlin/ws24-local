{"version":3,"names":["useEffect","useMemo","useRef","useValue","getResolvedParams","createTiming","useTiming","toOrParams","config","callback","prevCfgRef","resolvedParameters","nextParams","equals","current","value","from","prevAnimationRef","prevParamsRef","animation","undefined","a","b","JSON","stringify"],"sources":["useTiming.ts"],"sourcesContent":["import { useEffect, useMemo, useRef } from \"react\";\n\nimport type { SkiaValue, SkiaAnimation } from \"../../values/types\";\nimport type {\n  AnimationParams,\n  TimingConfig,\n  AnimationCallback,\n} from \"../types\";\nimport { useValue } from \"../../values/hooks/useValue\";\n\nimport { getResolvedParams } from \"./functions\";\nimport { createTiming } from \"./createTiming\";\n\n/**\n * Creats an animation value that will run whenever\n * the animation parameters change. The animation start immediately.\n * @param toOrParams\n * @param config\n * @returns A value that is animated\n */\nexport const useTiming = (\n  toOrParams: number | AnimationParams,\n  config?: TimingConfig,\n  callback?: AnimationCallback\n): SkiaValue<number> => {\n  // Resolve parameters - keep a cached version to avoid\n  // unnecesary re-renders.\n  const prevCfgRef = useRef<ReturnType<typeof getResolvedParams>>();\n  const resolvedParameters = useMemo(() => {\n    const nextParams = getResolvedParams(toOrParams, config);\n    if (!equals(prevCfgRef.current, nextParams)) {\n      prevCfgRef.current = nextParams;\n    }\n    return prevCfgRef.current!;\n  }, [config, toOrParams]);\n\n  // Create value\n  const value = useValue(resolvedParameters.from ?? 0);\n\n  // Create timing animation - keep a cached version to avoid\n  // uneccessary recreation of animations\n  const prevAnimationRef = useRef<SkiaAnimation>();\n  const prevParamsRef = useRef<typeof resolvedParameters>();\n  const animation = useMemo(() => {\n    if (!equals(prevParamsRef.current, resolvedParameters)) {\n      prevParamsRef.current = resolvedParameters;\n      prevAnimationRef.current = createTiming(\n        resolvedParameters,\n        value,\n        callback\n      );\n    }\n    return prevAnimationRef.current!;\n  }, [callback, resolvedParameters, value]);\n\n  // Run animation on the value - and stop it on unmount\n  useEffect(() => {\n    value.animation = animation;\n    return () => (value.animation = undefined);\n  }, [animation, value]);\n\n  // Return the value that is animated\n  return value;\n};\n\nconst equals = <T1, T2>(a: T1, b: T2) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,OAApB,EAA6BC,MAA7B,QAA2C,OAA3C;AAQA,SAASC,QAAT,QAAyB,6BAAzB;AAEA,SAASC,iBAAT,QAAkC,aAAlC;AACA,SAASC,YAAT,QAA6B,gBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,SAAS,GAAG,CACvBC,UADuB,EAEvBC,MAFuB,EAGvBC,QAHuB,KAID;EAAA;;EACtB;EACA;EACA,MAAMC,UAAU,GAAGR,MAAM,EAAzB;EACA,MAAMS,kBAAkB,GAAGV,OAAO,CAAC,MAAM;IACvC,MAAMW,UAAU,GAAGR,iBAAiB,CAACG,UAAD,EAAaC,MAAb,CAApC;;IACA,IAAI,CAACK,MAAM,CAACH,UAAU,CAACI,OAAZ,EAAqBF,UAArB,CAAX,EAA6C;MAC3CF,UAAU,CAACI,OAAX,GAAqBF,UAArB;IACD;;IACD,OAAOF,UAAU,CAACI,OAAlB;EACD,CANiC,EAM/B,CAACN,MAAD,EAASD,UAAT,CAN+B,CAAlC,CAJsB,CAYtB;;EACA,MAAMQ,KAAK,GAAGZ,QAAQ,0BAACQ,kBAAkB,CAACK,IAApB,yEAA4B,CAA5B,CAAtB,CAbsB,CAetB;EACA;;EACA,MAAMC,gBAAgB,GAAGf,MAAM,EAA/B;EACA,MAAMgB,aAAa,GAAGhB,MAAM,EAA5B;EACA,MAAMiB,SAAS,GAAGlB,OAAO,CAAC,MAAM;IAC9B,IAAI,CAACY,MAAM,CAACK,aAAa,CAACJ,OAAf,EAAwBH,kBAAxB,CAAX,EAAwD;MACtDO,aAAa,CAACJ,OAAd,GAAwBH,kBAAxB;MACAM,gBAAgB,CAACH,OAAjB,GAA2BT,YAAY,CACrCM,kBADqC,EAErCI,KAFqC,EAGrCN,QAHqC,CAAvC;IAKD;;IACD,OAAOQ,gBAAgB,CAACH,OAAxB;EACD,CAVwB,EAUtB,CAACL,QAAD,EAAWE,kBAAX,EAA+BI,KAA/B,CAVsB,CAAzB,CAnBsB,CA+BtB;;EACAf,SAAS,CAAC,MAAM;IACde,KAAK,CAACI,SAAN,GAAkBA,SAAlB;IACA,OAAO,MAAOJ,KAAK,CAACI,SAAN,GAAkBC,SAAhC;EACD,CAHQ,EAGN,CAACD,SAAD,EAAYJ,KAAZ,CAHM,CAAT,CAhCsB,CAqCtB;;EACA,OAAOA,KAAP;AACD,CA3CM;;AA6CP,MAAMF,MAAM,GAAG,CAASQ,CAAT,EAAgBC,CAAhB,KAA0B;EACvC,OAAOC,IAAI,CAACC,SAAL,CAAeH,CAAf,MAAsBE,IAAI,CAACC,SAAL,CAAeF,CAAf,CAA7B;AACD,CAFD"}